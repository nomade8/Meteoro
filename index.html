<!DOCTYPE html>
<html>
<head>
    <title>Meteoro</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            /* fundo com leve gradiente espacial */
            background: radial-gradient(1200px 800px at 50% 50%, #0b0f1a 0%, #000 60%);
        }
        canvas {
            display: block;
        }
        #score {
            position: fixed;
            top: 20px;
            left: 20px;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 24px;
            /* melhorias de legibilidade */
            background: rgba(0, 0, 0, 0.35);
            padding: 8px 12px;
            border-radius: 10px;
            box-shadow: 0 0 12px rgba(255,255,255,0.12);
            backdrop-filter: blur(2px);
        }
    </style>
</head>
<body>
    <div id="score">Pontos: <span id="points">0</span></div>
    <div id="lives" style="position: fixed; top: 20px; right: 20px; color: white; font-family: Arial, sans-serif; font-size: 24px; background: rgba(0, 0, 0, 0.35); padding: 8px 12px; border-radius: 10px; box-shadow: 0 0 12px rgba(255,255,255,0.12); backdrop-filter: blur(2px);">Vidas: <span id="livesCount">3</span></div>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const pointsDisplay = document.getElementById('points');
        const livesDisplay = document.getElementById('livesCount'); // NOVO: elemento para exibir vidas

        // Set canvas to full window size
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        let points = 0;
        let lives = 3; // NOVO: Variável para as vidas
        let meteors = [];
        let bullets = [];
        let stars = [];
        let particles = [];           // partículas de explosão
        let lastMeteorSpawn = 0;      // cooldown para spawn de meteoros

        // Adicionado: definir funções no escopo do script
        function createInitialMeteors() {
            for (let i = 0; i < 6; i++) {
                meteors.push(new Meteor(Math.random() * 20 + 80));
            }
        }

        function createExplosion(x, y, color) {
            for (let i = 0; i < 24; i++) {
                particles.push({
                    x,
                    y,
                    dx: (Math.random() - 0.5) * 6,
                    dy: (Math.random() - 0.5) * 6,
                    life: 42,
                    size: 2 + Math.random() * 2.5,
                    color
                });
            }
        }

        // Spaceship
        const ship = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            rotation: 0,
            size: 20,
            vx: 0,  // velocidade em x
            vy: 0   // velocidade em y
        };

        class Meteor {
            constructor(size) {
                this.size = size || 80;
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.max(canvas.width, canvas.height) * 0.5;
                this.x = canvas.width/2 + Math.cos(angle) * distance;
                this.y = canvas.height/2 + Math.sin(angle) * distance;
            
                // velocidade aleatória
                const speedMultiplier = 0.1;
                this.dx = ((Math.random() - 0.5) * 1.1 + speedMultiplier/2);
                this.dy = ((Math.random() - 0.5) * 1.1 + speedMultiplier/2);
            
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.2;
            
                const colors = ['#ff5252', '#58a6ff', '#ffe066', '#66ff91'];
                this.color = colors[Math.floor(Math.random() * colors.length)];
            
                this.points = [];
                const numPoints = 8;
                for (let i = 0; i < numPoints; i++) {
                    const ang = (i / numPoints) * Math.PI * 2;
                    const radius = this.size/2 * (0.9 + Math.random() * 0.4);
                    this.points.push({
                        x: Math.cos(ang) * radius,
                        y: Math.sin(ang) * radius
                    });
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
            
                ctx.beginPath();
                ctx.moveTo(this.points[0].x, this.points[0].y);
                for (let i = 1; i < this.points.length; i++) {
                    ctx.lineTo(this.points[i].x, this.points[i].y);
                }
                ctx.closePath();
            
                // estilo com brilho
                ctx.lineWidth = 2.5;
                ctx.strokeStyle = this.color;
                ctx.fillStyle = this.color + '22'; // leve preenchimento translúcido
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 14;
            
                ctx.fill();
                ctx.stroke();
                ctx.restore();
            }

            update() {
                this.x += this.dx;
                this.y += this.dy;
                this.rotation += this.rotationSpeed;

                if(this.x < -this.size) this.x = canvas.width + this.size;
                if(this.x > canvas.width + this.size) this.x = -this.size;
                if(this.y < -this.size) this.y = canvas.height + this.size;
                if(this.y > canvas.height + this.size) this.y = -this.size;
            }

            split() {
                if(this.size > 20) {
                    const newSize = this.size / 1.5;
                    const meteor1 = new Meteor(newSize);
                    const meteor2 = new Meteor(newSize);

                    meteor1.x = this.x; meteor1.y = this.y;
                    meteor2.x = this.x; meteor2.y = this.y;

                    meteor1.dx = this.dx * 0.8 + (Math.random() - 0.5) * 2;
                    meteor1.dy = this.dy * 0.8 + (Math.random() - 0.5) * 2;
                    meteor2.dx = this.dx * 0.8 + (Math.random() - 0.5) * 2;
                    meteor2.dy = this.dy * 0.8 + (Math.random() - 0.5) * 2;

                    meteors.push(meteor1);
                    meteors.push(meteor2);
                }
            }
        }

        // Game controls
        let rotatingLeft = false;
        let rotatingRight = false;
        let shooting = false;
        let thrusting = false;  // NOVO: acelerando pra frente
        let lastShot = 0;

        // Add pause state variable at the top with other game states
        let isPaused = false;
        let isGameOver = false;
        let invincible = false; // NOVO: Variável para invencibilidade temporária
        let invincibleTimer = 0; // NOVO: Timer para invencibilidade
        // Add to the keydown event listener
        document.addEventListener('keydown', (e) => {
            if(e.key === 'ArrowLeft') rotatingLeft = true;
            if(e.key === 'ArrowRight') rotatingRight = true;
            if(e.key === 'ArrowUp' || e.key.toLowerCase() === 'w') thrusting = true;
            if(e.key.toLowerCase() === 'x') shooting = true; // tiro com X
            if(e.key.toLowerCase() === 'p') isPaused = !isPaused; // Toggle pause
        });

        // Modify the gameLoop function
        document.addEventListener('keyup', (e) => {
            if(e.key === 'ArrowLeft') rotatingLeft = false;
            if(e.key === 'ArrowRight') rotatingRight = false;
            if(e.key === 'ArrowUp' || e.key.toLowerCase() === 'w') thrusting = false;
            if(e.key.toLowerCase() === 'x') shooting = false; // soltar X
        });

        // Remova todas as outras funções draw() e gameLoop() e mantenha apenas esta versão:
        // Adicione a função draw antes do gameLoop
                function draw() {
                    ctx.fillStyle = 'black';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Estrelas com movimento e brilho
                    stars.forEach(star => {
                        const alpha = star.alphaBase * (0.6 + 0.4 * Math.sin(star.tw));
                        ctx.save();
                        ctx.globalAlpha = alpha;
                        ctx.fillStyle = '#ffffff';
                        ctx.beginPath();
                        ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    });

                    // Nave
                    ctx.save();
                    ctx.translate(ship.x, ship.y);
                    ctx.rotate(ship.rotation);

                    // NOVO: Efeito de piscar
                    if (invincible && Math.floor(invincibleTimer / 10) % 2 === 0) { // Pisca a cada 10 frames
                        ctx.globalAlpha = 0.3; // Torna a nave semi-transparente
                    }

                    // glow da nave
                    ctx.shadowColor = '#7df9ff';
                    ctx.shadowBlur = 15;

                    // corpo da nave
                    ctx.beginPath();
                    ctx.moveTo(0, -ship.size);
                    ctx.lineTo(ship.size/2, ship.size);
                    ctx.lineTo(-ship.size/2, ship.size);
                    ctx.closePath();

                    const grad = ctx.createLinearGradient(0, -ship.size, 0, ship.size);
                    grad.addColorStop(0, '#ffffff');
                    grad.addColorStop(1, '#7df9ff');
                    ctx.strokeStyle = '#c8f7ff';
                    ctx.fillStyle = grad;
                    ctx.lineWidth = 2;
                    ctx.fill();
                    ctx.stroke();

                    // chama de propulsão quando ACELERANDO
                    if (thrusting) {
                        ctx.beginPath();
                        ctx.moveTo(0, ship.size);
                        ctx.lineTo(6, ship.size + 14 + Math.random() * 6);
                        ctx.lineTo(-6, ship.size + 14 + Math.random() * 6);
                        ctx.closePath();
                        const flameGrad = ctx.createLinearGradient(0, ship.size, 0, ship.size + 20);
                        flameGrad.addColorStop(0, '#ffd166');
                        flameGrad.addColorStop(1, '#ff4d4d');
                        ctx.fillStyle = flameGrad;
                        ctx.shadowColor = '#ffb347';
                        ctx.shadowBlur = 25;
                        ctx.fill();
                    }

                    ctx.restore();

                    // Tiros
                    ctx.fillStyle = '#fffb6a';
                    bullets.forEach(bullet => {
                        ctx.save();
                        ctx.shadowColor = '#fffb6a';
                        ctx.shadowBlur = 16;
                        ctx.beginPath();
                        ctx.arc(bullet.x, bullet.y, bullet.size, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    });

                    // Partículas
                    particles.forEach(p => {
                        ctx.save();
                        ctx.globalAlpha = Math.max(0, p.life / 42);
                        ctx.fillStyle = p.color || '#ffffff';
                        ctx.shadowColor = p.color || '#ffffff';
                        ctx.shadowBlur = 12;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    });

                    // Meteoros
                    meteors.forEach(meteor => meteor.draw());

                    // Tela de game over
                    if (isGameOver) {
                        ctx.save();
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.45)';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        ctx.fillStyle = 'red';
                        ctx.shadowColor = 'red';
                        ctx.shadowBlur = 18;
                        ctx.font = '72px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2);
                        ctx.font = '36px Arial';
                        ctx.fillStyle = 'white';
                        ctx.shadowColor = 'white';
                        ctx.shadowBlur = 10;
                        ctx.fillText(`Score: ${points}`, canvas.width/2, canvas.height/2 + 50);
                        ctx.restore();
                    }

                    // Pausa
                    if (isPaused) {
                        ctx.save();
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.35)';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        ctx.fillStyle = 'yellow';
                        ctx.font = '48px Arial';
                        ctx.textAlign = 'center';
                        ctx.shadowColor = 'yellow';
                        ctx.shadowBlur = 12;
                        ctx.fillText('PAUSA', canvas.width/2, canvas.height/2);
                        ctx.restore();
                    }
                }
        // Adicione estas funções antes do gameLoop
                function shoot() {
                    const now = Date.now();
                    if(now - lastShot > 100) {
                        const angle = ship.rotation - Math.PI/2;
                        bullets.push({
                            x: ship.x + Math.cos(angle) * ship.size,
                            y: ship.y + Math.sin(angle) * ship.size,
                            dx: Math.cos(angle) * 8,
                            dy: Math.sin(angle) * 8,
                            size: 3.5
                        });
                        lastShot = now;
                    }
                }

                function update() {
                    if (isGameOver) return;

                    // NOVO: Atualiza o timer de invencibilidade
                    if (invincible) {
                        invincibleTimer--;
                        if (invincibleTimer <= 0) {
                            invincible = false;
                        }
                    }

                    // Rotação e tiro
                    if(rotatingLeft) ship.rotation -= 0.05;
                    if(rotatingRight) ship.rotation += 0.05;
                    if(shooting) shoot();

                    // MOVIMENTO da nave
                    const angle = ship.rotation - Math.PI/2;
                    const accel = 0.15;
                    if (thrusting) {
                        ship.vx += Math.cos(angle) * accel;
                        ship.vy += Math.sin(angle) * accel;
                    }
                    // aplicar inércia e atrito leve
                    ship.x += ship.vx;
                    ship.y += ship.vy;
                    ship.vx *= 0.99;
                    ship.vy *= 0.99;
                    // wrap nas bordas
                    if (ship.x < 0) ship.x = canvas.width;
                    if (ship.x > canvas.width) ship.x = 0;
                    if (ship.y < 0) ship.y = canvas.height;
                    if (ship.y > canvas.height) ship.y = 0;

                    // Estrelas (movimento + cintilação)
                    stars.forEach(star => {
                        star.y += star.speed;
                        if (star.y > canvas.height) {
                            star.y = -2;
                            star.x = Math.random() * canvas.width;
                        }
                        star.tw += 0.05;
                    });

                    // Tiros
                    bullets = bullets.filter(bullet => {
                        bullet.x += bullet.dx;
                        bullet.y += bullet.dy;
                        return bullet.x > 0 && bullet.x < canvas.width &&
                               bullet.y > 0 && bullet.y < canvas.height;
                    });

                    // Meteoros e colisão com a nave
                    meteors.forEach(meteor => {
                        meteor.update();

                        const dx = meteor.x - ship.x;
                        const dy = meteor.y - ship.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if(distance < (meteor.size/2 + ship.size/2) && !invincible) { // NOVO: Verifica invencibilidade
                            lives--; // Decrementa uma vida
                            livesDisplay.textContent = lives; // Atualiza o display de vidas
                            createExplosion(ship.x, ship.y, '#7df9ff'); // Explosão na nave
                            
                            if (lives <= 0) {
                                isGameOver = true;
                                // Move o setTimeout para AQUI, para que só seja chamado quando o jogo realmente acabar
                                setTimeout(() => {
                                    isGameOver = false;
                                    meteors = [];
                                    bullets = [];
                                    particles = [];
                                    points = 0;
                                    lives = 3; // Reinicia as vidas
                                    pointsDisplay.textContent = points;
                                    livesDisplay.textContent = lives; // Atualiza o display de vidas
                                    ship.x = canvas.width / 2;
                                    ship.y = canvas.height / 2;
                                    ship.rotation = 0;
                                    ship.vx = 0;
                                    ship.vy = 0;
                                    createInitialMeteors();
                                }, 4000);
                            } else {
                                invincible = true; // Ativa invencibilidade
                                invincibleTimer = 180; // Duração da invencibilidade (3 segundos a 60fps)
                            }

                            // Limpa inputs
                            rotatingLeft = false;
                            rotatingRight = false;
                            shooting = false;
                            thrusting = false;

                            // Reposiciona a nave após ser atingida
                            ship.x = canvas.width / 2;
                            ship.y = canvas.height / 2;
                            ship.rotation = 0;
                            ship.vx = 0;
                            ship.vy = 0;
                        }
                    });

                    // Colisão tiro x meteoro
                    bullets.forEach((bullet, bulletIndex) => {
                        meteors.forEach((meteor, meteorIndex) => {
                            const dx = bullet.x - meteor.x;
                            const dy = bullet.y - meteor.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);

                            if(distance < meteor.size/2) {
                                // remove tiro e meteoro
                                bullets.splice(bulletIndex, 1);
                                meteors.splice(meteorIndex, 1);

                                // Explode e pontua por tamanho
                                createExplosion(meteor.x, meteor.y, meteor.color);
                                const gained = meteor.size >= 80 ? 5 : (meteor.size >= 40 ? 10 : 20);
                                points += gained;
                                pointsDisplay.textContent = points;

                                // Split em 2
                                meteor.split();
                            }
                        });
                    });

                    // Atualiza partículas (desaparecem com o tempo)
                    particles = particles.filter(p => {
                        p.x += p.dx;
                        p.y += p.dy;
                        p.dx *= 0.985;
                        p.dy *= 0.985;
                        p.life -= 1;
                        return p.life > 0;
                    });

                    // Spawn de novos meteoros (com cooldown)
                    const now = Date.now();
                    if (now - lastMeteorSpawn > 300) {
                        const bigMeteors = meteors.filter(m => m.size >= 80).length;
                        if (bigMeteors < 3) {
                            let spawnSize = Math.random() * 80 + 100; // 80 a 100 para grandes
                            meteors.push(new Meteor(spawnSize));
                        } else if (meteors.length < 15) {
                            let spawnSize = Math.random() * 40 + 40; // 40 a 80 para médios
                            meteors.push(new Meteor(spawnSize));
                        }
                        lastMeteorSpawn = now;
                    }
                }
        // Início do jogo: cria meteoros iniciais e inicia o loop
        createInitialMeteors();
        
        function gameLoop() {
            if (!isPaused) {
                update();
            }
            draw();
            requestAnimationFrame(gameLoop);
        }
        
        gameLoop();
    </script>
</body>
</html>
